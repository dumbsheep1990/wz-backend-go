# wz-backend-go 更新日志 (2025-04-25 至 2025-04-27)

## 项目更新

### API接口定义 (2025-04-27更新)

完成了以下微服务的API接口定义：

1. **interaction服务**
   - 文件：api/rpc/interaction.proto
   - 接口：
     - Like/Unlike: 点赞/取消点赞
     - Comment/DeleteComment: 发表/删除评论
     - Follow/Unfollow: 关注/取消关注
     - Report: 举报

2. **ai服务**
   - 文件：api/rpc/ai.proto
   - 接口：
     - Recommend: 获取推荐内容
     - ContentReview: 内容审核
     - Chat: 客服对话

3. **notification服务**
   - 文件：api/rpc/notification.proto
   - 接口：
     - Send: 发送通知
     - List: 获取通知列表
     - MarkRead: 标记通知为已读

4. **file服务**
   - 文件：api/rpc/file.proto
   - 接口：
     - Upload: 上传文件
     - GetFile: 获取文件信息
     - DeleteFile: 删除文件
     - ListFiles: 获取文件列表

5. **statistics服务**
   - 文件：api/rpc/statistics.proto
   - 接口：
     - UserBehavior: 获取用户行为统计
     - ContentPopularity: 获取内容流行度统计
     - HotContent: 获取热门内容
     - UserProfile: 获取用户画像

### RPC服务代码生成 (2025-04-27更新)

完成了以下微服务的RPC代码生成，包括以下服务：

1. **interaction服务**
   - 生成文件：
     - interaction.pb.go
     - interaction_grpc.pb.go
   - 功能：处理用户交互相关操作，包括点赞、评论、关注等

2. **ai服务**
   - 生成文件：
     - ai.pb.go
     - ai_grpc.pb.go
   - 功能：提供AI相关服务，包括推荐、内容审核、客服对话等

3. **notification服务**
   - 生成文件：
     - notification.pb.go
     - notification_grpc.pb.go
   - 功能：处理通知相关操作，包括发送通知、获取通知列表、标记已读等
   - 修复：将message Notification重命名为NotificationItem，避免与service名称冲突

4. **file服务**
   - 生成文件：
     - file.pb.go
     - file_grpc.pb.go
   - 功能：处理文件相关操作，包括上传、获取、删除文件等

5. **statistics服务**
   - 生成文件：
     - statistics.pb.go
     - statistics_grpc.pb.go
   - 功能：提供统计相关服务，包括用户行为统计、内容流行度统计等

### 技术实现

1. **代码生成工具**
   - 使用protoc生成protobuf代码
   - 使用protoc-gen-go生成Go代码
   - 使用protoc-gen-go-grpc生成gRPC服务代码

2. **目录结构**
   ```
   api/
   └── rpc/
       ├── interaction.proto   # 交互服务接口定义
       ├── ai.proto           # AI服务接口定义
       ├── notification.proto # 通知服务接口定义
       ├── file.proto         # 文件服务接口定义
       └── statistics.proto   # 统计服务接口定义

   internal/delivery/rpc/
   ├── interaction/     # 交互服务RPC代码
   ├── ai/             # AI服务RPC代码
   ├── notification/   # 通知服务RPC代码
   ├── file/           # 文件服务RPC代码
   └── statistics/     # 统计服务RPC代码
   ```

3. **依赖安装**
   - 安装goctl工具
   - 安装protoc-gen-go
   - 安装protoc-gen-go-grpc

### 下一步计划

1. 实现各个服务的RPC服务端代码
2. 添加服务注册和发现机制
3. 实现服务间的RPC调用
4. 添加服务监控和日志
5. 完善错误处理和重试机制 

# wz-backend-go 后端服务总结报告 (供前端开发参考)

## 1. 系统概述与核心架构

*   **项目名称**: `wz-backend-go`
*   **基本架构**: 采用 B2B2C 模式，整体为微服务架构，支持多租户。
*   **技术栈核心**: Go语言, gRPC, Kafka, Nacos, OpenTelemetry, Elasticsearch, Redis。
*   **主要微服务划分**:
    *   **核心业务服务**: 用户服务, 内容服务, 搜索服务, 交易服务 (这些服务在早期规划中提及，具体接口定义在本次分析的README中未完全展开)。
    *   **通用接口服务**: 公共接口服务。
    *   **新增专项微服务 (已有gRPC接口定义)**:
        *   `interaction` 服务: 处理用户互动，如点赞、评论、关注等。
        *   `ai` 服务: 提供AI能力，如推荐、内容审核、客服对话。
        *   `notification` 服务: 负责消息通知。
        *   `file` 服务: 管理文件上传与访问。
        *   `statistics` 服务: 进行数据统计与分析。

## 2. API 接入层：API 网关 (Gateway)

API 网关是所有外部请求（包括前端应用）的统一入口。

*   **主要功能**:
    *   HTTP 请求路由与转发。
    *   自动将 HTTP 请求转换为对内部 gRPC 服务的调用。
    *   支持动态路由规则管理，可通过 RESTful API (`/api/v1/registry/...`) 进行配置和查询。
    *   集成服务注册与发现 (Nacos)。
*   **API 文档**:
    *   基于 OpenAPI/Swagger 规范自动生成。
    *   提供 Swagger UI 界面，方便前端开发者查阅和测试 API。
*   **认证与授权**:
    *   **认证机制**:
        *   **JWT (JSON Web Tokens)**: 主要认证方式，支持令牌生成、验证、刷新和撤销。
        *   支持 API Key, OAuth2, Basic Auth 等多种认证方式。
    *   **多因素认证 (MFA)**: 基于 TOTP (Time-based One-Time Password) 实现。
    *   **授权机制**: 基于 Casbin 实现 RBAC (Role-Based Access Control)，进行细粒度的权限控制。
*   **可靠性与安全增强**:
    *   **请求限流**: 采用基于 Redis 的分布式令牌桶算法，支持按 IP、用户ID、租户ID、请求路径等维度进行限流。
    *   **服务熔断**: 集成 `gobreaker` 库，当后端服务出现故障或延迟过高时，能快速失败，防止雪崩。
    *   **多租户识别**: 网关中间件能从子域名、请求头 (`X-Tenant-ID`) 或 URL 参数中识别租户信息。

## 3. 核心微服务接口概览 (基于 .proto 定义)

以下是部分已明确接口定义的微服务及其功能，前端开发时需关注其具体的请求/响应结构 (详见 Swagger API 文档)：

*   **`interaction` 服务 (`api/rpc/interaction.proto`)**:
    *   `Like` / `Unlike`: 点赞/取消点赞。
    *   `Comment` / `DeleteComment`: 发表/删除评论。
    *   `Follow` / `Unfollow`: 关注/取消关注用户。
    *   `Report`: 举报不良内容或行为。
*   **`ai` 服务 (`api/rpc/ai.proto`)**:
    *   `Recommend`: 获取个性化推荐内容。
    *   `ContentReview`: 对用户提交的内容进行审核。
    *   `Chat`: 提供客服聊天机器人功能。
*   **`notification` 服务 (`api/rpc/notification.proto`)**:
    *   `Send`: 发送通知给用户。
    *   `List`: 获取用户的通知列表。
    *   `MarkRead`: 标记通知为已读。
    *   *注意: 消息结构 `Notification` 已重命名为 `NotificationItem`*。
*   **`file` 服务 (`api/rpc/file.proto`)**:
    *   `Upload`: 上传文件。
    *   `GetFile`: 获取文件信息。
    *   `DeleteFile`: 删除文件。
    *   `ListFiles`: 获取文件列表。
*   **`statistics` 服务 (`api/rpc/statistics.proto`)**:
    *   `UserBehavior`: 获取用户行为统计数据。
    *   `ContentPopularity`: 获取内容流行度统计。
    *   `HotContent`: 获取当前热门内容。
    *   `UserProfile`: 获取用户画像数据。

## 4. 服务通信与内部机制

这些是后端系统内部的机制，前端通常不直接交互，但了解它们有助于理解系统行为：

*   **同步通信**: 服务间主要通过 gRPC 进行高效的同步调用。
*   **异步通信**: 使用 Kafka 作为消息队列，处理用户事件（注册、登录等）和内容事件（发布、更新等），实现服务解耦和最终一致性。
*   **服务注册与发现**: 使用 Nacos。所有微服务实例启动后会注册到 Nacos，API 网关和其他服务通过 Nacos 发现目标服务地址。提供了相关 API (`/api/v1/registry/...`) 查询服务状态。
*   **分布式链路追踪**: 全面集成 OpenTelemetry。从 API 网关接收到请求开始，到内部各微服务间的调用，再到数据库等外部依赖的访问，都会被追踪。这有助于快速定位问题和分析性能瓶颈。Trace ID 和 Span ID 会在服务间通过上下文传递。
*   **服务上下文 (Service Context)**: 在每个服务内部，通过统一的 Service Context 管理数据库连接、缓存客户端、gRPC 客户端等依赖。

## 5. 数据管理

*   **缓存**:
    *   采用两级缓存架构：Redis 作为分布式缓存，辅以本地内存缓存以提升性能。
    *   缓存策略支持 TTL (Time-To-Live)、条件刷新、前缀清理等。
*   **搜索引擎**: 使用 Elasticsearch 实现强大的搜索功能，支持文档索引、批量操作、高级搜索（过滤、排序、高亮、聚合）。
*   **数据库**: (具体数据库类型未在文档中明确，但使用了 GORM 作为 ORM)。数据库层面已实现多租户数据过滤。

## 6. 多租户与多平台支持

系统设计充分考虑了多租户和多客户端平台的需求。

*   **多租户数据隔离**:
    *   **租户识别**: API 网关通过子域名、请求头 (如 `X-Tenant-ID`) 或 URL 参数自动识别租户。
    *   **上下文传递**: 租户 ID 会在整个调用链中通过上下文传递。
    *   **数据隔离**:
        *   在数据库层面自动为 SQL 查询添加租户过滤条件。
        *   支持多种隔离模式：逻辑隔离 (共享表，通过 `tenant_id` 字段区分)、物理隔离 (不同租户使用不同数据库或表)、共享表 (某些表数据对所有租户可见)。
*   **多平台适配**:
    *   **平台识别**: 后端能够识别请求来源的客户端平台类型，定义了枚举 `AppPlatform`:
        *   `web`: 网页浏览器
        *   `mobile`: 原生移动应用 (iOS, Android)
        *   `uniapp`: UniApp 构建的应用
    *   **响应适配**: 引入了响应适配器 (Response Adapter) 架构。后端可以根据识别到的 `AppPlatform`，对返回给前端的数据结构或内容进行调整和优化，以适应不同平台的显示需求或特性。

## 7. 系统可观测性

为了保障系统稳定运行和快速排错，系统具备以下可观测性能力：

*   **日志**: (虽然具体日志方案未详述，但各组件如追踪、服务上下文均有提及日志记录)。
*   **指标 (Metrics)**: 集成 Prometheus 进行关键性能指标 (QPS, 延迟, 错误率等) 的收集和监控。
*   **追踪 (Tracing)**: 基于 OpenTelemetry 实现全链路分布式追踪。
*   **告警 (Alerting)**: 建立在 Prometheus 指标之上，拥有可配置的告警规则引擎，支持通过多种渠道（如邮件、Slack等，具体渠道待确认）发送告警通知。

## 8. 前端开发对接要点与建议

1.  **API 入口与文档**:
    *   所有后端请求均通过 API 网关。请产品或后端负责人提供网关的访问地址。
    *   务必通过 API 网关提供的 Swagger UI 详细了解每个接口的请求参数、请求体、响应结构、认证方式等。
2.  **认证流程**:
    *   明确项目采用的具体认证方式 (大概率是 JWT)。
    *   与后端确认 JWT Token 的获取方式 (如登录接口)、传递方式 (通常在 HTTP Header `Authorization: Bearer <token>`)、过期策略及刷新机制。
    *   如果涉及 MFA，了解其启用和验证流程。
3.  **租户信息传递**:
    *   根据前端应用的架构和用户体验设计，与后端协商确定传递租户ID的方式 (子域名、请求头 `X-Tenant-ID`、或特定接口的参数)。
    *   对于需要区分租户的请求，务必正确传递租户信息。
4.  **平台类型声明**:
    *   了解后端是如何自动识别平台类型的 (可能通过 User-Agent 或特定的请求头)。
    *   如果需要前端显式声明平台类型，确认约定的方式 (如自定义请求头 `X-App-Platform: web/mobile/uniapp`)，以便获取平台适配后的 API 响应。
5.  **错误处理**:
    *   熟悉 API 网关统一的错误响应格式。
    *   关注 HTTP 状态码，并根据错误码和错误信息进行相应的用户提示或处理。
6.  **关注点分离**:
    *   前端应主要关注业务逻辑的实现和用户体验的优化。后端的微服务拆分、服务间通信、数据存储等细节对前端应该是透明的。
7.  **数据交互**:
    *   充分利用 `statistics` 服务获取的数据进行前端展示。
    *   与 `ai` 服务交互实现智能推荐、内容审核等功能。
    *   通过 `notification` 服务实现消息推送和展示。
    *   文件上传/下载/管理通过 `file` 服务。
    *   用户间的互动行为通过 `interaction` 服务。
8.  **环境**:
    *   确认开发、测试、生产等不同环境的 API 网关地址和相关配置。

## 9. 注意事项与潜在风险

*   **文档与实际一致性**: 虽然有自动生成的 API 文档，但在开发初期，建议与后端开发人员保持密切沟通，验证接口行为是否与文档描述完全一致。
*   **业务逻辑完整性**: 部分 README 提及某些微服务的"核心业务逻辑"仍在开发中或计划中。前端在设计依赖这些逻辑的功能时，需与后端确认其可用性和实现进度。
*   **平台适配细节**: 响应适配器的具体适配规则和效果，需要前端在不同平台上进行实际测试和验证。
*   **依赖管理**: 后端系统组件较多 (Nacos, Kafka, Redis, ES 等)，前端开发调试时，需确保后端环境的完整性和稳定性。

---

这份总结基于您提供的 README 文件。实际项目开发中，建议建立持续的沟通渠道，并参考更详细的设计文档和 API 规范。

希望这份总结能帮助您的团队顺利开展前端开发工作！ 